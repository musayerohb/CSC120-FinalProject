# CSC120-FinalProject

## Deliverables:
 - Your final codebase
 - Your revised annotated architecture diagram
 - Design justification (including a brief discussion of at least one alternative you considered)
 - A map of your game's layout (if applicable)
 - `cheatsheet.md`
 - Completed `rubric.md`

## Design Justification
Our idea of combat originally was that of a turn-based RPG, complete with health and attack methods. We later changed the format to the user unlocking a 'use' ability and programming a series of alternate options and endings determined by what item the user selects to use against the bandits. This turned out to be far less time-consuming and allowed us to build on the pre-existing methods of grabbableItems and inventory rather than build a whole new section of the game that abandons all of that. 

Our original concept for the house included it having multiple floors. We then realized that giving a whole attribute for the number of floors of the house in the backend was unncessary as it has no impact on the methods or story. Therefore, we decided that it was easier to have the whole house laid out as a single floor while using the print statements that the user sees while moving around the house imply multiple floors.

We decided to have two of the five rooms have more than one adjacent room to simulate how houses connect some rooms in more than one spot, but not all rooms are connected to each other. This prevents the user from being overwhlemed about where to go next while still feeling like they have more than one option or route for exploring the house. Additionally, it makes it easier for the user to go back and look around rooms they've already been to if needed.

## Additional Reflection Questions
 - What was your **overall approach** to tackling this project?
 - What **new thing(s)** did you learn / figure out in completing this project?
 - Is there anything that you wish you had **implemented differently**?
 - If you had **unlimited time**, what additional features would you implement?
 - What was the most helpful **piece of feedback** you received while working on your project? Who gave it to you?
 - If you could go back in time and give your past self some **advice** about this project, what hints would you give?
 - _If you worked with a team:_ please comment on how your **team dynamics** influenced your experience working on this project.

1. Our overall goal was to program as efficiently as possible. We aimed to categorize the aspects of the game into methods so that we could call them in different points of the game when necessary (i.e being able to call the open function no matter which room the user is in). We wanted to take object-oriented aspect to heart by making some methods responsible for or directly interact with others. For example, the objects the user can interact with change based on the room they're in. The user is responsible for interacting with items by opening, looking under them, etc. The house's placeInRoom method is resposible for initializing the objects that the user can interact and how the user can interact with them in each room. Finally, the villager's conversation method was the dialogue tree and is responsible for starting the exploratory section of the game. 

2. Hashtables proved to be vital for this project. Going in, we had planned to use array lists to create the objects the user could interact with and the way the game reacted when they interacted with them. However, we quickly learned that hashtables were a better option because of the way we could use scanners to check whether the keys were present in a user's input and have the program print its description if they were. Hashtables were a concept we had never used prior to taking 120, but we were glad to have found a use for it because it saved us many printing lines of code.

3. I wish we had implemented inheritance for our different room classes. After we had already created all of the rooms as separate classes, we realized that it would have been way more parsimonious to simply make one class called 'Rooms' with all of the hashtables we needed for each room (since the hashtables for each room were all named exactly the same way), instead of separate classes with the same lines of code over and over. In terms of making our code easier to read and just more concise, that would have been an improvement. 

4. If we had unlimited time, we probably would have used reputation scores instead of doing away with it. Before writing our code, we wanted a reputation score that would be modified based on how the player went through the dialogue with the villager and whether or not they decided to take or return the ring. Eventually, this reputation score would come into play during the last stage of the game with the bandits, where the reputation score would affect whether or not you'd be able to get away or placed directly into the fight scene (for example, you could have convinced the bandits to let you go if you had a high reputation or they would have instantly fought you if your reputation was low enough). We also would have made the meeting with the bandits more expansive by implementing turn-based combat (the ring, being magical, could even heal you!). However, time constraints made both of these plans too much to do in too little time.

5. The most helpful feedback we received was from a TA called Sami about how we should go about implementing navigation around the house. We had already implemented all of the room classes and the user commands were all working as intended when we changed the user's current location manually, but we had no clue how to get the user from one location to another only using the front-end part of the program (the terminal). Sami looked at our code and gave us two options: allowing the user to move throughout the rooms in the house through a grid map that would store the user's coordinates after every move (thus only allowing them to move throughout the house by moving directly to the doors coordinates), or just creating a function that would essentially allow the user to directly open doors to adjacent rooms and enter them through simple commands. Although the former option would have made our game more interactive through allowing users to interact with objects and doors themselves only after they've moved towards them, Sami recommended the second one because it would have been easier to code within the time frame we had (considering we had other features to implement) and probably easier for users. This advice was so helpful in allowing us to actually think about how to take an abstract idea like walking through a house into actual implementable java code, something that was a huge and fundamental aspect of our game that we got really stuck on. 

6. We would tell our past selves to create attributes for classes as we went along rather than make a bunch at once based on our original vision of the project. This is beause, due to time, we had to scrap some concepts we had already begun to program, which caused us to throw away a decent amount of time along with it. Had we focused on programming the parts of the program we absolutely knew we were going to be in the final version of the project (i.e the open, look under, and look around methods), we could have saved a bit of time and also gotten rid of bugs in those 'concrete' methods more quickly.

7. Having worked together on past assignments and projects, we had decided to try only to work on the project together at the same time. This allowed us to both be constantly updated on what was working, what wasn't, and what stood somewhere in-between. We also helped eachother during the project in different ways: Musa helped Eva recall how to write certain commands (remove(), this., etc.), and Eva helped Musa recognize when we should refer to TAs, Jordan, or other classmates for help and get people to playtest so more bugs could be found and fixed. Overall, we both contributed to the project equally in programming, but uniquely in approach, which made for a great working environment for both of us!